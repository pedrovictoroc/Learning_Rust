--------------------------------------
                RUST
--------------------------------------


|-> Criação de funções
    -> Para criar funções usamos a sintaxe fn nome_função(){}

|-> Mostrando na tela
    -> Para fazermos um print chamamos a Macro println!()

    -> Para criarmos uma função de mesmo nome com função print
       precisamos apenas remover o !

|-> Cargo
    -> É um criador de sistemas e gerenciador de pacotes do Rust
       similar a criar um arquivo com create-react-app
       a pasta criada contem uma pasta src, um .gitignore e um Cargo.toml
    
    -> Criamos usando "cargo new nome_do_arquivo"

    -> Responsável por fazer a build do código, baixar as bibliotecas necessárias
       e gerenciar as dependências
    
    -> Cargo.toml
        * Significado
            - TOML = Tom's Obvious, Minimal Language
        
        * Contém um Package, onde ficam as informações básicas

        * Dependencies, abaixo seguirá a lista de dependências
          do código, os packages de código são referenciados como CRATES

    -> Podemos fazer build e run do projeto usando o Cargo

        * cargo build
            - Esse comando cria um arquivo Cargo.lock responsável
              por manter salvo a versão de todas as dependencias utilizadas
            
            - Cria uma pasta target, ao executarmos ./target/debug/nome_projeto.exe
              executamos o programa
        
        * cargo run
            - Ao invés de utilizar o comando de execução podemos também usar este
            
            - Cargo nota as alterações de código e automaticamente recompila
        
        * cargo check
            - Compila o código sem gerar executável

            - Suas vantagens consistem em sua velocidade em relação ao cargo build
              e no fato de que geralmente queremos apenas testar a ausência de erros de compilação
        
        * cargo build --release
            -Gera um código otimizado em Release, ao invés de Debug em Target

|-> Autorizando entrada de dados
    -> Para isso adicionamos ao topo do código "use std::io;"
       da biblioteca std

    -> ao usarmos io::stdin().read_line(&mut variable).expect("fail message")
       estamos chamando a função read_line que se atribui da função de colocar a submissão
       do usuário em &mut variable
        * O uso de & identifica uma referência
            - &variable faz referência a uma variável não mutável
        
        * .expect() é chamado se o Result da função for "err", se for "ok", essa parte será ignorada
          é importante notar que isso lança a mensagem de erro customizada

|-> Armazenamento de variáves
    EX: let mut guess = String:new();

    -> A funçãod o let é criar a variável e, caso necessário, linkar a algum valor

    -> ATENÇÃO, FUNÇÃO DO MUT
        * No RUST variáveis são imutáveis por default, entretando
          ao adicionarmos mut logo após let, definimos que ela é mutável
    
    -> String::new()
        * Essa sintaxe nos retorna uma String vazia

        * ::new() nos indica que é uma função associada a String

|-> Tipos numéricos
    -> Número de 32 bits: i32

    -> Número de 32 bits sem sinal: u32

    -> Número de 64 bits: i64

    -> Número de 64 bits sem sinal: u64

|-> Variáveis e mutabilidade
    -> Existem dois tipos de definição de variável: LET E CONST

        * Let
            - Por padrão é imutável, tal condição pode ser alterada adicionando MUT após o let
                > Podemos utilizar de Shadowing e simplesmente sobrescrever a variável
                    #EXEMPLO: (let teste: u32 = 4000; let teste:u32 = 50;)
                > Utilizando mut evitamos errar ao esquercermos de usar let antes da variável a ser sobrescrita
                    #OBSERVAÇÃO: Em contra partida, não podemos alterar o tipo desta variável apenas por ser mutável
        
        * Const
            - Seu comportamento é sempre de imutabilidade, não pode ser alterado
            - As boas práticas do Rust dizem para utilizar nomes em Caps Lock com underscore
                > Exemplo: const MAX_VALUE: u32 = 10000;
                    #OBSERVAÇÃO: podemos também escrever: 10_000, o Rust entenderá como 10000


|-> Tipos de dados
    -> Scalar
        * Integer
            - Como definir:
                
                LENGHT      Signed      Unsigned
                
                8-bit        i8            u8
                16-bit       i16           u16
                32-bit       i32           u32
                64-bit       i64           u64
                128-bit      i128          u128
        
        * Float
            - Temos dois tipos, f32 e f64, entretando, por padrão, o f64 será usado
        
        * Boolean
            - Podemos definir de duas formas, implicitamente e explcitamente
                > Implicitamente
                    #Exemplo: let t = true;
                
                > Explicitamente
                    #Exemplo: let f: bool = false;
        
        * Character
            - Um char em Rust tolera não só letras, mas, também, caracteres especiais, emojis e representações de espaço nulo
    
    -> Compound
        * Tuple
            - Uma vez declarada, não pode ser alterada

            #Exemplo: let tup: (i32,f64,u8) = (500, 6.4,1);
            
            - Podemos fazer acessos diretos a tupla, tup.0, por exemplo, retornaria 500
        
        * Array
            - Todos os elementos de um array devem ter o mesmo tipo
            - Arrays em Rust tem tamanho fixo

            - Podemos definir de forma implicita ou explicita
                > Implicitamente
                    #Exemplo: let a  = [1,2,3,4,5];
                    #Exemplo: let a = [3;5] a resposta será um array inicializado com 5 posições contendo 3
                
                > Explicitamente
                    #Exemplo: let a: [i32;5] = [1,2,3,4,5];